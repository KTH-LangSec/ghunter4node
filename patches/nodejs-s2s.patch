diff --git a/.gitignore b/.gitignore
index 79920931ce..ada2a9da6d 100644
--- a/.gitignore
+++ b/.gitignore
@@ -26,6 +26,7 @@
 !.yamllint.yaml
 
 # === Rules for root dir ===
+/fuzzing*
 /core
 /vgcore.*
 /v8*.log
diff --git a/deps/v8/src/builtins/builtins-definitions.h b/deps/v8/src/builtins/builtins-definitions.h
index 18da8a651b..95b461fa10 100644
--- a/deps/v8/src/builtins/builtins-definitions.h
+++ b/deps/v8/src/builtins/builtins-definitions.h
@@ -634,6 +634,7 @@ namespace internal {
   CPP(GlobalEscape)                                                            \
   CPP(GlobalUnescape)                                                          \
   CPP(GlobalEval)                                                              \
+  CPP(GlobalLog)                                                               \
   /* ES6 #sec-isfinite-number */                                               \
   TFJ(GlobalIsFinite, kJSArgcReceiverSlots + 1, kReceiver, kNumber)            \
   /* ES6 #sec-isnan-number */                                                  \
diff --git a/deps/v8/src/builtins/builtins-global.cc b/deps/v8/src/builtins/builtins-global.cc
index 137f7f3402..d426a13d12 100644
--- a/deps/v8/src/builtins/builtins-global.cc
+++ b/deps/v8/src/builtins/builtins-global.cc
@@ -112,5 +112,29 @@ BUILTIN(GlobalEval) {
       Execution::Call(isolate, function, target_global_proxy, 0, nullptr));
 }
 
+// log info about tained data from JS
+BUILTIN(GlobalLog) {
+  HandleScope scope(isolate);
+  Handle<String> str;
+  ASSIGN_RETURN_FAILURE_ON_EXCEPTION(
+      isolate, str,
+      Object::ToString(isolate, args.atOrUndefined(isolate, 1)));
+
+  {
+    str = i::String::Flatten(isolate, str);
+    int length = str->length();
+    uint8_t* message = new uint8_t[length + 1];
+    i::String::WriteToFlat(*str, message, 0, length);
+    message[length] = '\0';
+
+    // LOG!!!
+    FuzzStream os;
+    os << "[From JS] " << (char*)message << "\n";
+    delete[] message;
+  }
+
+  return ReadOnlyRoots(isolate).undefined_value();
+}
+
 }  // namespace internal
 }  // namespace v8
diff --git a/deps/v8/src/codegen/compiler.cc b/deps/v8/src/codegen/compiler.cc
index 3204e37c88..6cdda440c4 100644
--- a/deps/v8/src/codegen/compiler.cc
+++ b/deps/v8/src/codegen/compiler.cc
@@ -14,6 +14,7 @@
 #include "src/base/logging.h"
 #include "src/base/optional.h"
 #include "src/base/platform/time.h"
+#include "src/base/strings.h"
 #include "src/baseline/baseline.h"
 #include "src/codegen/assembler-inl.h"
 #include "src/codegen/compilation-cache.h"
@@ -2864,6 +2865,12 @@ MaybeHandle<JSFunction> Compiler::GetFunctionFromEval(
     ParseRestriction restriction, int parameters_end_pos,
     int eval_scope_position, int eval_position,
     ParsingWhileDebugging parsing_while_debugging) {
+  if (strcasestr(source->ToCString().get(), "0xEFFACED")) {
+    // LOG!!!
+    FuzzStream os;
+    os << "EVAL!!!\n";
+  }
+
   Isolate* isolate = context->GetIsolate();
 
   // The cache lookup key needs to be aware of the separation between the
diff --git a/deps/v8/src/ic/accessor-assembler.cc b/deps/v8/src/ic/accessor-assembler.cc
index 7f83c0f6c6..b173d5b11d 100644
--- a/deps/v8/src/ic/accessor-assembler.cc
+++ b/deps/v8/src/ic/accessor-assembler.cc
@@ -3220,19 +3220,19 @@ void AccessorAssembler::LoadIC_NoFeedback(const LoadICParameters* p,
   {
     // Special case for Function.prototype load, because it's very common
     // for ICs that are only executed once (MyFunc.prototype.foo = ...).
-    Label not_function_prototype(this, Label::kDeferred);
-    GotoIfNot(IsJSFunctionInstanceType(instance_type), &not_function_prototype);
-    GotoIfNot(IsPrototypeString(p->name()), &not_function_prototype);
+    //Label not_function_prototype(this, Label::kDeferred);
+    GotoIfNot(IsJSFunctionInstanceType(instance_type), &miss);//&not_function_prototype);
+    GotoIfNot(IsPrototypeString(p->name()), &miss);//&not_function_prototype);
 
     GotoIfPrototypeRequiresRuntimeLookup(CAST(lookup_start_object),
                                          lookup_start_object_map,
-                                         &not_function_prototype);
+                                         &miss);//&not_function_prototype);
     Return(LoadJSFunctionPrototype(CAST(lookup_start_object), &miss));
-    BIND(&not_function_prototype);
+    //BIND(&not_function_prototype);
   }
 
-  GenericPropertyLoad(CAST(lookup_start_object), lookup_start_object_map,
-                      instance_type, p, &miss, kDontUseStubCache);
+  // GenericPropertyLoad(CAST(lookup_start_object), lookup_start_object_map,
+  //                     instance_type, p, &miss, kDontUseStubCache);
 
   BIND(&miss);
   {
@@ -3441,119 +3441,8 @@ void AccessorAssembler::KeyedLoadIC(const LoadICParameters* p,
   ExitPoint direct_exit(this);
 
   TVARIABLE(MaybeObject, var_handler);
-  Label if_handler(this, &var_handler), try_polymorphic(this, Label::kDeferred),
-      try_megamorphic(this, Label::kDeferred),
-      try_uninitialized(this, Label::kDeferred),
-      try_polymorphic_name(this, Label::kDeferred),
-      miss(this, Label::kDeferred), generic(this, Label::kDeferred);
-
-  TNode<Map> lookup_start_object_map =
-      LoadReceiverMap(p->receiver_and_lookup_start_object());
-  GotoIf(IsDeprecatedMap(lookup_start_object_map), &miss);
-
-  GotoIf(IsUndefined(p->vector()), &generic);
-
-  // Check monomorphic case.
-  TNode<HeapObjectReference> weak_lookup_start_object_map =
-      MakeWeak(lookup_start_object_map);
-  TNode<HeapObjectReference> feedback = TryMonomorphicCase(
-      p->slot(), CAST(p->vector()), weak_lookup_start_object_map, &if_handler,
-      &var_handler, &try_polymorphic);
-  BIND(&if_handler);
-  {
-    LazyLoadICParameters lazy_p(p);
-    HandleLoadICHandlerCase(
-        &lazy_p, var_handler.value(), &miss, &direct_exit, ICMode::kNonGlobalIC,
-        OnNonExistent::kReturnUndefined, kSupportElements, access_mode);
-  }
-
-  BIND(&try_polymorphic);
-  TNode<HeapObject> strong_feedback = GetHeapObjectIfStrong(feedback, &miss);
-  {
-    // Check polymorphic case.
-    Comment("KeyedLoadIC_try_polymorphic");
-    GotoIfNot(IsWeakFixedArrayMap(LoadMap(strong_feedback)), &try_megamorphic);
-    HandlePolymorphicCase(weak_lookup_start_object_map, CAST(strong_feedback),
-                          &if_handler, &var_handler, &miss);
-  }
-
-  BIND(&try_megamorphic);
-  {
-    // Check megamorphic case.
-    Comment("KeyedLoadIC_try_megamorphic");
-    Branch(TaggedEqual(strong_feedback, MegamorphicSymbolConstant()), &generic,
-           &try_uninitialized);
-  }
-
-  BIND(&generic);
-  {
-    // TODO(jkummerow): Inline this? Or some of it?
-    TailCallBuiltin(
-        access_mode == LoadAccessMode::kLoad ? Builtin::kKeyedLoadIC_Megamorphic
-                                             : Builtin::kKeyedHasIC_Megamorphic,
-        p->context(), p->receiver(), p->name(), p->slot(), p->vector());
-  }
-
-  BIND(&try_uninitialized);
-  {
-    // Check uninitialized case.
-    Comment("KeyedLoadIC_try_uninitialized");
-    Branch(TaggedEqual(strong_feedback, UninitializedSymbolConstant()), &miss,
-           &try_polymorphic_name);
-  }
-
-  BIND(&try_polymorphic_name);
-  {
-    // We might have a name in feedback, and a weak fixed array in the next
-    // slot.
-    Comment("KeyedLoadIC_try_polymorphic_name");
-    TVARIABLE(Name, var_name);
-    Label if_polymorphic_name(this), feedback_matches(this),
-        if_internalized(this), if_notinternalized(this, Label::kDeferred);
-
-    // Fast-case: The recorded {feedback} matches the {name}.
-    GotoIf(TaggedEqual(strong_feedback, p->name()), &feedback_matches);
-
-    {
-      // Try to internalize the {name} if it isn't already.
-      TVARIABLE(IntPtrT, var_index);
-      TryToName(p->name(), &miss, &var_index, &if_internalized, &var_name,
-                &miss, &if_notinternalized);
-    }
 
-    BIND(&if_internalized);
-    {
-      // The {var_name} now contains a unique name.
-      Branch(TaggedEqual(strong_feedback, var_name.value()),
-             &if_polymorphic_name, &miss);
-    }
-
-    BIND(&if_notinternalized);
-    {
-      TVARIABLE(IntPtrT, var_index);
-      TryInternalizeString(CAST(p->name()), &miss, &var_index, &if_internalized,
-                           &var_name, &miss, &miss);
-    }
-
-    BIND(&feedback_matches);
-    {
-      var_name = CAST(p->name());
-      Goto(&if_polymorphic_name);
-    }
-
-    BIND(&if_polymorphic_name);
-    {
-      // If the name comparison succeeded, we know we have a weak fixed array
-      // with at least one map/handler pair.
-      TailCallBuiltin(access_mode == LoadAccessMode::kLoad
-                          ? Builtin::kKeyedLoadIC_PolymorphicName
-                          : Builtin::kKeyedHasIC_PolymorphicName,
-                      p->context(), p->receiver(), var_name.value(), p->slot(),
-                      p->vector());
-    }
-  }
-
-  BIND(&miss);
+  //BIND(&miss);
   {
     Comment("KeyedLoadIC_miss");
     TailCallRuntime(
diff --git a/deps/v8/src/ic/ic.cc b/deps/v8/src/ic/ic.cc
index 630f4db9c8..afc2dc8010 100644
--- a/deps/v8/src/ic/ic.cc
+++ b/deps/v8/src/ic/ic.cc
@@ -401,6 +401,8 @@ void IC::ConfigureVectorState(
 MaybeHandle<Object> LoadIC::Load(Handle<Object> object, Handle<Name> name,
                                  bool update_feedback,
                                  Handle<Object> receiver) {
+  // FuzzStream os;
+  // os << "[LoadIC::Load]: " << name << "\n"; 
   bool use_ic = (state() != NO_FEEDBACK) && v8_flags.use_ic && update_feedback;
 
   if (receiver.is_null()) {
@@ -450,6 +452,13 @@ MaybeHandle<Object> LoadIC::Load(Handle<Object> object, Handle<Name> name,
   // Named lookup in the object.
   LookupForRead(&it, IsAnyHas());
 
+  if (!it.IsFound() && it.CheckedPrototype()) {
+    // Changed by mshc
+    // LOG!!!
+    FuzzStream os;
+    os << "[LoadIC::Load] NOT FOUND: " << name << "\n";
+  }
+
   if (it.IsFound() || !ShouldThrowReferenceError()) {
     // Update inline cache and stub cache.
     if (use_ic) {
@@ -485,6 +494,9 @@ MaybeHandle<Object> LoadGlobalIC::Load(Handle<Name> name,
                                        bool update_feedback) {
   Handle<JSGlobalObject> global = isolate()->global_object();
 
+  // FuzzStream os;
+  // os << "[LoadGlobalIC::Load]: " << name << "\n";
+
   if (IsString(*name)) {
     // Look up in script context table.
     Handle<String> str_name = Handle<String>::cast(name);
@@ -1471,6 +1483,9 @@ MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(Handle<Object> object,
                                              Handle<Object> key) {
   Handle<Object> result;
 
+  // FuzzStream os;
+  // os << "[KeyedLoadIC::RuntimeLoad]: " << key << "\n";
+
   if (IsKeyedLoadIC()) {
     ASSIGN_RETURN_ON_EXCEPTION(
         isolate(), result, Runtime::GetObjectProperty(isolate(), object, key),
@@ -1486,6 +1501,9 @@ MaybeHandle<Object> KeyedLoadIC::RuntimeLoad(Handle<Object> object,
 
 MaybeHandle<Object> KeyedLoadIC::Load(Handle<Object> object,
                                       Handle<Object> key) {
+  // FuzzStream os;
+  // os << "[KeyedLoadIC::Load]: " << key << "\n";
+
   if (MigrateDeprecated(isolate(), object)) {
     return RuntimeLoad(object, key);
   }
@@ -2646,6 +2664,10 @@ RUNTIME_FUNCTION(Runtime_LoadIC_Miss) {
   // Runtime functions don't follow the IC's calling convention.
   Handle<Object> receiver = args.at(0);
   Handle<Name> key = args.at<Name>(1);
+
+  // FuzzStream os;
+  // os << "[Runtime_LoadIC_Miss]: " << key << "\n";
+
   int slot = args.tagged_index_value_at(2);
   Handle<FeedbackVector> vector = args.at<FeedbackVector>(3);
   FeedbackSlot vector_slot = FeedbackVector::ToSlot(slot);
@@ -2680,6 +2702,16 @@ RUNTIME_FUNCTION(Runtime_LoadNoFeedbackIC_Miss) {
   // Runtime functions don't follow the IC's calling convention.
   Handle<Object> receiver = args.at(0);
   Handle<Name> key = args.at<Name>(1);
+
+  // FuzzStream os;
+  // os << "[Runtime_LoadNoFeedbackIC_Miss]: " << key << "\n";
+
+  // base::ScopedVector<char> name_buffer(100);
+  // key->NameShortPrint(name_buffer);
+  // if (strcmp(name_buffer.begin(), "obj") == 0) {
+  //   os << "THIS IS obj!!\n";
+  // }
+
   int slot_kind = args.smi_value_at(2);
   FeedbackSlotKind kind = static_cast<FeedbackSlotKind>(slot_kind);
 
@@ -2700,6 +2732,9 @@ RUNTIME_FUNCTION(Runtime_LoadWithReceiverNoFeedbackIC_Miss) {
   Handle<Object> object = args.at(1);
   Handle<Name> key = args.at<Name>(2);
 
+  // FuzzStream os;
+  // os << "[Runtime_LoadWithReceiverNoFeedbackIC_Miss]: " << key << "\n";
+
   Handle<FeedbackVector> vector = Handle<FeedbackVector>();
   FeedbackSlot vector_slot = FeedbackSlot::Invalid();
   LoadIC ic(isolate, vector, vector_slot, FeedbackSlotKind::kLoadProperty);
@@ -2713,6 +2748,10 @@ RUNTIME_FUNCTION(Runtime_LoadGlobalIC_Miss) {
   // Runtime functions don't follow the IC's calling convention.
   Handle<JSGlobalObject> global = isolate->global_object();
   Handle<String> name = args.at<String>(0);
+
+  // FuzzStream os;
+  // os << "[Runtime_LoadGlobalIC_Miss]: " << name << "\n";
+
   int slot = args.tagged_index_value_at(1);
   Handle<HeapObject> maybe_vector = args.at<HeapObject>(2);
   int typeof_value = args.smi_value_at(3);
@@ -2741,6 +2780,9 @@ RUNTIME_FUNCTION(Runtime_LoadGlobalIC_Slow) {
   DCHECK_EQ(3, args.length());
   Handle<String> name = args.at<String>(0);
 
+  // FuzzStream os;
+  // os << "[Runtime_LoadGlobalIC_Slow]: " << name << "\n";
+
   int slot = args.tagged_index_value_at(1);
   Handle<FeedbackVector> vector = args.at<FeedbackVector>(2);
   FeedbackSlot vector_slot = FeedbackVector::ToSlot(slot);
@@ -2759,6 +2801,10 @@ RUNTIME_FUNCTION(Runtime_LoadWithReceiverIC_Miss) {
   Handle<Object> receiver = args.at(0);
   Handle<Object> object = args.at(1);
   Handle<Name> key = args.at<Name>(2);
+
+  // FuzzStream os;
+  // os << "[Runtime_LoadWithReceiverIC_Miss]: " << key << "\n";
+
   int slot = args.tagged_index_value_at(3);
   Handle<FeedbackVector> vector = args.at<FeedbackVector>(4);
   FeedbackSlot vector_slot = FeedbackVector::ToSlot(slot);
@@ -3388,6 +3434,11 @@ RUNTIME_FUNCTION(Runtime_LoadPropertyWithInterceptor) {
   HandleScope scope(isolate);
   DCHECK_EQ(5, args.length());
   Handle<Name> name = args.at<Name>(0);
+
+  // LOG!!!
+  FuzzStream os;
+  os << "[Runtime_LoadPropertyWithInterceptor]: " << name << "\n";
+
   Handle<Object> receiver = args.at(1);
   Handle<JSObject> holder = args.at<JSObject>(2);
 
@@ -3497,6 +3548,10 @@ RUNTIME_FUNCTION(Runtime_LoadElementWithInterceptor) {
   DCHECK_GE(args.smi_value_at(1), 0);
   uint32_t index = args.smi_value_at(1);
 
+  // LOG!!!
+  FuzzStream os;
+  os << "[Runtime_LoadElementWithInterceptor]: " << "\n";
+
   Handle<InterceptorInfo> interceptor(receiver->GetIndexedInterceptor(),
                                       isolate);
   PropertyCallbackArguments arguments(isolate, interceptor->data(), *receiver,
diff --git a/deps/v8/src/init/bootstrapper.cc b/deps/v8/src/init/bootstrapper.cc
index 2beaf45b14..5d4c74c441 100644
--- a/deps/v8/src/init/bootstrapper.cc
+++ b/deps/v8/src/init/bootstrapper.cc
@@ -5899,6 +5899,10 @@ bool Genesis::InstallABunchOfRandomThings() {
     native_context()->set_global_eval_fun(*eval);
   }
 
+  // Install Global.log for tainting messages
+  InstallFunctionWithBuiltinId(isolate(), global_object, "log",
+                               Builtin::kGlobalLog, 1, false);
+
   // Install Global.isFinite
   InstallFunctionWithBuiltinId(isolate(), global_object, "isFinite",
                                Builtin::kGlobalIsFinite, 1, true);
diff --git a/deps/v8/src/objects/lookup-inl.h b/deps/v8/src/objects/lookup-inl.h
index da1e593625..0e90e46b9a 100644
--- a/deps/v8/src/objects/lookup-inl.h
+++ b/deps/v8/src/objects/lookup-inl.h
@@ -18,6 +18,7 @@
 #include "src/objects/map-inl.h"
 #include "src/objects/name-inl.h"
 #include "src/objects/objects-inl.h"
+#include "src/utils/ostreams.h"
 
 namespace v8 {
 namespace internal {
@@ -74,6 +75,15 @@ LookupIterator::LookupIterator(Isolate* isolate, Handle<Object> receiver,
       receiver_(receiver),
       lookup_start_object_(lookup_start_object),
       index_(index) {
+  
+  // FuzzStream os;
+  // os << "[LookupIterator]: ";
+  // if (!name_.is_null()) {
+  //   os << name_;
+  // }
+
+  // os << "=CTOR=\n";
+
   if (IsElement()) {
     // If we're not looking at a TypedArray, we will need the key represented
     // as an internalized string.
diff --git a/deps/v8/src/objects/lookup.cc b/deps/v8/src/objects/lookup.cc
index a5fd238767..8aba25a353 100644
--- a/deps/v8/src/objects/lookup.cc
+++ b/deps/v8/src/objects/lookup.cc
@@ -111,6 +111,7 @@ void LookupIterator::NextInternal(Tagged<Map> map, Tagged<JSReceiver> holder) {
     holder = maybe_holder;
     map = holder->map(isolate_);
     state_ = LookupInHolder<is_element>(map, holder);
+    checked_prototype_ = true;
   } while (!IsFound());
 
   holder_ = handle(holder, isolate_);
diff --git a/deps/v8/src/objects/lookup.h b/deps/v8/src/objects/lookup.h
index 4ee8b47f68..9a47ae6b35 100644
--- a/deps/v8/src/objects/lookup.h
+++ b/deps/v8/src/objects/lookup.h
@@ -12,6 +12,7 @@
 #include "src/objects/js-objects.h"
 #include "src/objects/map.h"
 #include "src/objects/objects.h"
+#include "src/utils/ostreams.h"
 
 #if V8_ENABLE_WEBASSEMBLY
 #include "src/wasm/value-type.h"
@@ -132,11 +133,35 @@ class V8_EXPORT_PRIVATE LookupIterator final {
 
   inline bool IsPrivateName() const;
 
-  bool IsFound() const { return state_ != NOT_FOUND; }
+  bool IsFound() const { 
+    // if (state_ == NOT_FOUND) {
+    //   FuzzStream os;
+    //   os << "[LookupIterator::IsFound] NOT FOUND: ";
+    //   if (!name_.is_null()) {
+    //     os << name_;
+    //   }
+
+    //   os << "\n";
+    // }
+
+    return state_ != NOT_FOUND; 
+  }
+  bool CheckedPrototype() const {
+    return checked_prototype_;
+  }
+
   void Next();
   void NotFound() {
     has_property_ = false;
     state_ = NOT_FOUND;
+
+    // FuzzStream os;
+    // os << "[LookupIterator::NotFound] NOT FOUND: ";
+    // if (!name_.is_null()) {
+    //   os << name_;
+    // }
+
+    // os << "=INTERNAL=\n";
   }
 
   Heap* heap() const { return isolate_->heap(); }
@@ -313,6 +338,7 @@ class V8_EXPORT_PRIVATE LookupIterator final {
   // HolderIsReceiverOrHiddenPrototype.
   const Configuration configuration_;
   State state_ = NOT_FOUND;
+  bool checked_prototype_ = false;
   bool has_property_ = false;
   InterceptorState interceptor_state_ = InterceptorState::kUninitialized;
   PropertyDetails property_details_ = PropertyDetails::Empty();
diff --git a/deps/v8/src/runtime/runtime-object.cc b/deps/v8/src/runtime/runtime-object.cc
index 770f8efa8f..9710f53e44 100644
--- a/deps/v8/src/runtime/runtime-object.cc
+++ b/deps/v8/src/runtime/runtime-object.cc
@@ -18,6 +18,7 @@
 #include "src/objects/property-details.h"
 #include "src/objects/swiss-name-dictionary-inl.h"
 #include "src/runtime/runtime.h"
+#include "src/utils/ostreams.h"
 
 namespace v8 {
 namespace internal {
@@ -39,6 +40,15 @@ MaybeHandle<Object> Runtime::GetObjectProperty(
   LookupIterator it =
       LookupIterator(isolate, receiver, lookup_key, lookup_start_object);
 
+  if (!it.IsFound() && it.CheckedPrototype()) {
+    // Changed by mshc
+    // LOG!!!
+    FuzzStream os;
+    os << "[Runtime::GetObjectProperty] NOT FOUND: " << key;
+    os << "\n";
+  }
+
+
   MaybeHandle<Object> result = Object::GetProperty(&it);
   if (result.is_null()) {
     return result;
@@ -777,6 +787,9 @@ RUNTIME_FUNCTION(Runtime_GetProperty) {
     receiver_obj = args.at<Object>(2);
   }
 
+  // FuzzStream os;
+  // os << "[Runtime_GetProperty]: " << key_obj << "\n";
+
   // Fast cases for getting named properties of the lookup_start_obj JSObject
   // itself.
   //
diff --git a/deps/v8/src/utils/ostreams.cc b/deps/v8/src/utils/ostreams.cc
index 36a8080c8b..d25e7543ea 100644
--- a/deps/v8/src/utils/ostreams.cc
+++ b/deps/v8/src/utils/ostreams.cc
@@ -5,6 +5,15 @@
 #include "src/utils/ostreams.h"
 
 #include <cinttypes>
+#include <cstring>
+#include <unistd.h>
+#include <fcntl.h>
+
+#include <stdio.h>
+#include <dirent.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+
 
 #include "src/base/lazy-instance.h"
 #include "src/objects/string.h"
@@ -114,9 +123,109 @@ std::streamsize AndroidLogStream::xsputn(const char* s, std::streamsize n) {
 }
 #endif
 
+fdoutbuf::fdoutbuf(int fd) :fd(fd) {
+  if (this->fd == -1) {
+    std::perror("Error opening taint.log");
+    std::exit(1);
+  }
+}
+
+fdoutbuf::int_type fdoutbuf::overflow(int_type c) {
+  if (c != EOF) {
+    char z = c;
+    if (write(fd, &z, 1) != 1) {
+      return EOF;
+    }
+  }
+  return c;
+}
+
+int fdoutbuf::size = 0;
+std::streamsize fdoutbuf::xsputn(const char* s, std::streamsize num) {
+  // we assume that FuzzStream writes line by line and 1'000'000
+  // lines is our threshold to avoid creating big files on a disk
+  if (size > 1000000)
+    return 0;
+
+  size++;
+  return write(fd, s, num);
+}
+
 DEFINE_LAZY_LEAKY_OBJECT_GETTER(base::RecursiveMutex,
                                 StdoutStream::GetStdoutMutex)
 
+DEFINE_LAZY_LEAKY_OBJECT_GETTER(base::RecursiveMutex,
+                                FuzzStream::GetFuzzMutex)
+
+int FuzzStream::file = -1;
+FuzzStream::FuzzStream() {
+  buf = new fdoutbuf(getFile());
+  this->init(buf);
+}
+
+FuzzStream::~FuzzStream() {
+  delete buf;
+}
+
+int FuzzStream::getFile() {
+  if (file < 0) {
+    DIR *dir;
+    struct dirent *entry;
+
+    const std::string folderPath = /*%PLACEHOLDER% LOGPATH*/ "/src/node/fuzzing/tmp/";
+    if (opendir(folderPath.c_str()) == NULL) {
+      mkdir(folderPath.c_str(), 0755);
+
+    }
+
+    dir = opendir(folderPath.c_str());
+    int dcount = 0;
+    while ((entry = readdir(dir)) != NULL) {
+      if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
+        continue;
+      }
+
+      dcount++;
+    }
+
+    std::string subdirPath = "";
+    if (dcount == 0) {
+      subdirPath = folderPath + "/logs_1";
+      mkdir(subdirPath.c_str(), 0755);
+      dir = opendir(subdirPath.c_str());
+    } else {
+      subdirPath = folderPath + "/logs_" + std::to_string(dcount);
+      dir = opendir(subdirPath.c_str());
+    }
+
+
+    int lcount = 0;
+    while ((entry = readdir(dir)) != NULL) {
+      if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0) {
+        continue;
+      }
+
+      lcount++;
+    }
+
+    if (lcount < 10000) {
+      int count = lcount;
+      do
+      {
+        std::string filePath = subdirPath + "/taint_" + std::to_string(count++) + ".log";
+        file = open(filePath.c_str(), O_WRONLY | O_CREAT | O_EXCL, 0644);
+      } while (file < 0);
+    } else {
+      std::string newDirPath = folderPath + "/logs_" + std::to_string(dcount+1);
+      mkdir(newDirPath.c_str(), 0755);
+      std::string filePath = newDirPath + "/taint_1.log";
+      file = open(filePath.c_str(), O_WRONLY | O_CREAT | O_EXCL, 0644);
+    }
+  }
+
+  return file;
+}
+
 namespace {
 
 // Locale-independent predicates.
diff --git a/deps/v8/src/utils/ostreams.h b/deps/v8/src/utils/ostreams.h
index 0b5bca95ea..ee3cd29950 100644
--- a/deps/v8/src/utils/ostreams.h
+++ b/deps/v8/src/utils/ostreams.h
@@ -98,6 +98,33 @@ class StdoutStream : public OFStream {
 
   base::RecursiveMutexGuard mutex_guard_{GetStdoutMutex()};
 };
+
+class fdoutbuf : public std::streambuf {
+ public:
+  fdoutbuf(int fd);
+
+ protected:
+  virtual int_type overflow(int_type c) override;
+  virtual std::streamsize xsputn(const char* s, std::streamsize num) override;
+
+ private:
+  static int size;
+  int fd;
+};
+
+class FuzzStream : public std::ostream {
+ public:
+  FuzzStream();
+  virtual ~FuzzStream();
+
+ private:
+  static int file;
+  static int getFile();
+  static V8_EXPORT_PRIVATE base::RecursiveMutex* GetFuzzMutex();
+
+  base::RecursiveMutexGuard mutex_guard_{GetFuzzMutex()};
+  fdoutbuf* buf;
+};
 #endif
 
 class StderrStream : public OFStream {
diff --git a/lib/internal/bootstrap/realm.js b/lib/internal/bootstrap/realm.js
index c6935c6f77..f1a265ca16 100644
--- a/lib/internal/bootstrap/realm.js
+++ b/lib/internal/bootstrap/realm.js
@@ -54,17 +54,64 @@ const {
   ArrayPrototypePush,
   ArrayPrototypeSlice,
   Error,
+  ObjectCreate,
   ObjectDefineProperty,
   ObjectKeys,
+  ObjectGetOwnPropertyDescriptor,
   ObjectPrototypeHasOwnProperty,
   ObjectSetPrototypeOf,
+  ObjectValues,
   ReflectGet,
+  ReflectHas,
   SafeMap,
   SafeSet,
   String,
   StringPrototypeStartsWith,
   StringPrototypeSlice,
   TypeError,
+  ReflectApply,
+  ReflectConstruct,
+  ReflectOwnKeys,
+  ReflectGetPrototypeOf,
+
+  // all known prototypes:
+  AggregateErrorPrototype,
+  ArrayPrototype,
+  ArrayBufferPrototype,
+  AsyncIteratorPrototype,
+  BigIntPrototype,
+  BigInt64ArrayPrototype,
+  BigUint64ArrayPrototype,
+  BooleanPrototype,
+  DataViewPrototype,
+  DatePrototype,
+  ErrorPrototype,
+  EvalErrorPrototype,
+  Float32ArrayPrototype,
+  Float64ArrayPrototype,
+  FunctionPrototype,
+  Int16ArrayPrototype,
+  Int32ArrayPrototype,
+  Int8ArrayPrototype,
+  MapPrototype,
+  NumberPrototype,
+  ObjectPrototype,
+  RangeErrorPrototype,
+  ReferenceErrorPrototype,
+  RegExpPrototype,
+  SetPrototype,
+  StringPrototype,
+  SymbolPrototype,
+  SyntaxErrorPrototype,
+  TypeErrorPrototype,
+  URIErrorPrototype,
+  Uint16ArrayPrototype,
+  Uint32ArrayPrototype,
+  Uint8ArrayPrototype,
+  Uint8ClampedArrayPrototype,
+  WeakMapPrototype,
+  WeakSetPrototype,
+  PromisePrototype,
 } = primordials;
 
 // Set up process.moduleLoadList.
@@ -146,6 +193,9 @@ const experimentalModuleList = new SafeSet();
 
   process.binding = function binding(module) {
     module = String(module);
+    if (globalThis.log) {
+      globalThis.log(`binding[${moduleLoadList.length}]: ${module}`);
+    }
     // Deprecated specific process.binding() modules, but not all, allow
     // selective fallback to internalBinding for the deprecated ones.
     if (processBindingAllowList.has(module)) {
@@ -168,8 +218,13 @@ const experimentalModuleList = new SafeSet();
   process._linkedBinding = function _linkedBinding(module) {
     module = String(module);
     let mod = bindingObj[module];
-    if (typeof mod !== 'object')
+    if (typeof mod !== 'object') {
+      if (globalThis.log) {
+        globalThis.log(`_linkedBinding[${moduleLoadList.length}]: ${module}`);
+      }
+
       mod = bindingObj[module] = getLinkedBinding(module);
+    }
     return mod;
   };
 }
@@ -179,15 +234,364 @@ const experimentalModuleList = new SafeSet();
  * @type {import('typings/globals').internalBinding}
  */
 let internalBinding;
+let wrapper;
 {
+  // %PLACEHOLDER% WRAP
+  function Wrapper(logCallback, beforeFuncCallback, afterFuncCallback) {
+    this.log = logCallback;
+    this.beforeFunc = beforeFuncCallback;
+    this.afterFunc = afterFuncCallback;
+    this.cache = new WeakSet();
+  }
+  
+  Wrapper.prototype.wrapPrototype = function (source, accessPath, level) {
+    const proto = ReflectGetPrototypeOf(source);
+    if (proto) {
+      if (proto === ArrayPrototype ||
+          proto === ArrayBufferPrototype ||
+          proto === AsyncIteratorPrototype ||
+          proto === BigIntPrototype ||
+          proto === BigInt64ArrayPrototype ||
+          proto === BigUint64ArrayPrototype ||
+          proto === BooleanPrototype ||
+          proto === DataViewPrototype ||
+          proto === DatePrototype ||
+          proto === ErrorPrototype ||
+          proto === EvalErrorPrototype ||
+          proto === Float32ArrayPrototype ||
+          proto === Float64ArrayPrototype ||
+          proto === FunctionPrototype ||
+          proto === Int16ArrayPrototype ||
+          proto === Int32ArrayPrototype ||
+          proto === Int8ArrayPrototype ||
+          proto === MapPrototype ||
+          proto === NumberPrototype ||
+          proto === ObjectPrototype ||
+          proto === RangeErrorPrototype ||
+          proto === ReferenceErrorPrototype ||
+          proto === RegExpPrototype ||
+          proto === SetPrototype ||
+          proto === StringPrototype ||
+          proto === SymbolPrototype ||
+          proto === SyntaxErrorPrototype ||
+          proto === TypeErrorPrototype ||
+          proto === URIErrorPrototype ||
+          proto === Uint16ArrayPrototype ||
+          proto === Uint32ArrayPrototype ||
+          proto === Uint8ArrayPrototype ||
+          proto === Uint8ClampedArrayPrototype ||
+          proto === WeakMapPrototype ||
+          proto === WeakSetPrototype ||
+          proto === PromisePrototype) {
+        return;
+      }
+  
+      this.wrap(proto, accessPath + '.__proto__', level + 1);
+    }
+  }
+  
+  Wrapper.prototype.wrapProperty = function (source, key, dest, accessPath, level) {
+    const descriptor = ObjectGetOwnPropertyDescriptor(source, key);
+    if (descriptor) {
+      let keyString;
+      if (typeof key === 'symbol') {
+        keyString = `[symbol]${key.toString()}`
+      } else {
+        // key should be string
+        keyString = key;
+      }
+  
+      if (ObjectPrototypeHasOwnProperty(descriptor, 'value')) {
+        const wrappedValue = this.wrap(descriptor.value, accessPath + '.' + keyString, level + 1);
+        if (source !== dest) {
+          ObjectDefineProperty(dest, key, {
+            enumerable: descriptor.enumerable,
+            configurable: descriptor.configurable,
+            writable: descriptor.writable,
+            value: wrappedValue
+          });
+        } else if (typeof descriptor.value === 'function') {
+          if (descriptor.configurable) {
+            ObjectDefineProperty(dest, key, {
+              enumerable: descriptor.enumerable,
+              configurable: descriptor.configurable,
+              writable: descriptor.writable,
+              value: wrappedValue
+            });
+          } else if (descriptor.writable) {
+            dest[key] = wrappedValue;
+          } else {
+            this.log('[WARNING] Not replaced the property: ' + accessPath + '.' + keyString);
+          }
+        }
+      }
+      else {
+        if (source !== dest || descriptor.configurable) {
+          let wrappedGetter;
+          if (descriptor.get) {
+            wrappedGetter = this.wrap(descriptor.get, accessPath + '.[getter]' + keyString, level + 1);
+          }
+  
+          let wrappedSetter;
+          if (descriptor.set) {
+            wrappedSetter = this.wrap(descriptor.set, accessPath + '.[setter]' + keyString, level + 1);
+          }
+  
+          ObjectDefineProperty(dest, key, {
+              enumerable: descriptor.enumerable,
+              configurable: descriptor.configurable,
+              get: wrappedGetter,
+              set: wrappedSetter
+          })
+        } else {
+          this.log(`[WARNING] The property ${accessPath + '.' + keyString} cannot be wrapped due to configurable is ${descriptor.configurable}`)
+        }
+      }
+    }
+  }
+  
+  Wrapper.prototype.wrap = function (source, accessPath, level = 0) {
+    if (!source) {
+      return source;
+    }
+  
+    if (level > 9) {
+      this.log('[WARNING] Interrupt wrapping the object: ' + accessPath)
+      return source;
+    }
+  
+    if (typeof source === 'function') {
+      if (source.constructor.name === "AsyncFunction") {
+        this.log('[WARNING] Not support async functions');
+        return source;
+      }
+  
+      if (this.cache.has(source)) {
+        // we already wrapped the function
+        return source;
+      }
+  
+      if (source.constructor.name === 'GeneratorFunction' ||
+          source.constructor.name === 'AsyncGeneratorFunction') {
+        // https://stackoverflow.com/a/19660350/1815957
+        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator
+        // https://javascript.info/generators
+        this.log('[WARNING] Not support Generator functions');
+        return source;
+      }
+  
+      const wrapperThis = this;
+      const f = function () {
+        let accessPathNew = accessPath + '()';
+        // if (!accessPath.includes('(') && arguments.length > 0) {
+        //   accessPathNew = accessPath + `('${arguments[0]}')`;
+        // } else {
+        //   accessPathNew = accessPath + '()';
+        // }
+  
+        const needToWrap = wrapperThis.beforeFunc(accessPathNew, arguments);
+        let ret;
+        if (new.target) {
+          const newTarget = ReflectGetPrototypeOf(this).constructor;
+          ret = ReflectConstruct(source, arguments, newTarget);
+        } else {
+          ret = ReflectApply(source, this, arguments);
+        }
+  
+        if (wrapperThis.afterFunc) {
+          wrapperThis.afterFunc(accessPathNew, arguments, ret);
+        }
+  
+        if (needToWrap) {
+          return wrapperThis.wrap(ret, accessPathNew, level + 1);
+        } else {
+          return ret;
+        }
+      }
+  
+      if (source.name && source.name != '') {
+        ObjectDefineProperty(f, 'name', { value: source.name, writable: false });
+      }
+  
+      // if source is a class, then properties are static members
+      for (const key of ReflectOwnKeys(source)) {
+        if (key === 'length' ||
+            key === 'name' ||
+            key === 'prototype') {
+          // ignore built-in properties of functions
+          continue;
+        }
+  
+        this.wrapProperty(source, key, f, accessPath + '.' + source.name, level);
+      }
+  
+      if (source.prototype) {
+        for (const key of ReflectOwnKeys(source.prototype)) {
+          if (key === 'constructor') {  // recursive link to the function `source`
+            ObjectDefineProperty(source.prototype, 'constructor', {
+              enumerable: false,
+              configurable: true,
+              writable: true,
+              value: f
+            })
+          } else {
+            this.wrapProperty(source.prototype, key, source.prototype, accessPath + '.' + source.name + '.prototype', level);
+          }
+        }
+  
+        f.prototype = source.prototype;
+      }
+      else {
+        f.prototype = null;
+      }
+  
+      this.cache.add(f);
+      return f;
+    }
+  
+    if (typeof source === 'object') {
+      if (this.cache.has(source)) {
+        return source;
+      }
+  
+      this.cache.add(source);
+      // HOW to wrap arrays?
+      this.wrapPrototype(source, accessPath, level);
+      for (const key of ReflectOwnKeys(source)) {
+        this.wrapProperty(source, key, source, accessPath, level);
+      }
+  
+      return source;
+    }
+  
+    // seems it is a primitive value
+    return source;
+  }
+  // %PLACEHOLDER% END
+
+  function beforeFuncCallback(accessPath, args) {
+    function searchTaintedImpl(obj, level) {
+      if (level <= 0) {
+        //log('[WARNING] Interrupt looking for a taint mark.');
+        return undefined;
+      }
+
+      if (obj === undefined || obj === null)
+        return undefined;
+
+      const objType = typeof obj;
+      if (objType === 'function')
+        return undefined;
+
+      if (objType === 'string') {
+        if (obj === '0xEFFACED')
+          return { path: "", value: '0xEFFACED' };
+
+        if (obj.startsWith('// %TESTCASE%'))
+          return undefined;
+
+        if (obj.match(/EFFACED|251636973/i))  // 251636973 is 0xEFFACED in dec
+          return { path: "", value: obj };
+      }
+      else if (objType === 'number') {
+        if (obj === 0xEFFACED) {
+          return { path: "", value: '[Number]0xEFFACED' };
+        }
+
+        let s = obj.toString(16);
+        if (s.includes('effaced')) {
+          return { path: "", value: '[Number]' + s };
+        }
+      }
+      else if (objType === 'object') {
+        try {
+          if (ReflectHas(obj, Symbol.iterator) && typeof ReflectGet(obj, Symbol.iterator) === 'function') {
+            let index = 0;
+            for (const item of obj) {
+              let res = searchTaintedImpl(item, level - 1);
+              if (res) {
+                return { path: `[${index}]${res.path}`, value: res.value};
+              }
+
+              index++;
+            }
+          }
+        } catch { }
+
+        try {
+          // in some test cases ReflectOwnKeys throws the exception: Cannot perform 'ownKeys' on a proxy that has been revoked
+          for (const key of ReflectOwnKeys(obj)) {
+            if (key === '__effaced')
+              return { path: ".__effaced", value: obj.__effaced };
+
+            let val = undefined;
+            try {
+              // the getter can throw an exception, just ignore it
+              val = obj[key];
+            } catch { }
+
+            if (val !== ObjectPrototype) {
+              // Don't analyze Object.prototype even if we get a direct ref to it
+              // Object.prototype always has tainted property and we force reading of this prop in the line `val = obj[key];`
+              // that makes this line a `source` for our taint analysis
+              // we may get a direct ref to Object.prototype via buildin.exports.primordials.ObjectPrototype
+              // when running `node --expose-internals`
+              let res = searchTaintedImpl(val, level - 1);
+              if (res) {
+                return { path: `[${key}]${res.path}`, value: res.value };
+              }
+            }
+          }
+        } catch { }
+
+        let toStringVal = undefined;
+        try {
+          toStringVal = obj.toString();
+        } catch { }
+
+        if (toStringVal && !toStringVal.startsWith('// %TESTCASE%')) {
+          const matchRes = toStringVal.match(/EFFACED(\d+)/i);
+          if (matchRes) {
+            return { path: `.toString()`, value: `0x${matchRes[0].toUpperCase()}` };
+          }
+        }
+      }
+
+      return undefined;
+    }
+
+    for (let i = 0; i < args.length; i++) {
+      let res = searchTaintedImpl(args[i], 10);
+      if (res) {
+        let msg = '    ' + accessPath + ' has ' + i + 'th TAINTED arg: ' + res.value.replace(/\n/g, '\\n').replace(/\r/g, '\\r') + (res.path ? (' at ' + res.path) : '');
+        try {
+          throw new Error();
+        } catch (error) {
+          msg = msg + ' | sink stack: ' + error.stack.replace(/\n/g, '\\n').replace(/\r/g, '\\r');
+        }
+
+        log(msg);
+      }
+    }
+
+    return false;
+  }
+
+  wrapper = new Wrapper(log, beforeFuncCallback);
+
   const bindingObj = { __proto__: null };
   // eslint-disable-next-line no-global-assign
   internalBinding = function internalBinding(module) {
     let mod = bindingObj[module];
     if (typeof mod !== 'object') {
-      mod = bindingObj[module] = getInternalBinding(module);
+      if (globalThis.log) {
+        globalThis.log(`internalBinding[${moduleLoadList.length}]: ${module}`);
+      }
+      
+      mod = bindingObj[module] = wrapper.wrap(getInternalBinding(module), module);
       ArrayPrototypePush(moduleLoadList, `Internal Binding ${module}`);
     }
+
     return mod;
   };
 }
@@ -208,7 +612,7 @@ const getOwn = (target, property, receiver) => {
 const publicBuiltinIds = builtinIds
   .filter((id) =>
     !StringPrototypeStartsWith(id, 'internal/') &&
-      !experimentalModuleList.has(id),
+    !experimentalModuleList.has(id),
   );
 // Do not expose the loaders to user land even with --expose-internals.
 const internalBuiltinIds = builtinIds
@@ -305,8 +709,8 @@ class BuiltinModule {
   static isBuiltin(id) {
     return BuiltinModule.canBeRequiredWithoutScheme(id) || (
       typeof id === 'string' &&
-        StringPrototypeStartsWith(id, 'node:') &&
-        BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(id, 5))
+      StringPrototypeStartsWith(id, 'node:') &&
+      BuiltinModule.canBeRequiredByUsers(StringPrototypeSlice(id, 5))
     );
   }
 
@@ -348,7 +752,7 @@ class BuiltinModule {
     ArrayPrototypePush(exportsKeys, 'default');
     this.module = new ModuleWrap(
       url, undefined, exportsKeys,
-      function() {
+      function () {
         builtin.syncExports();
         this.setExport('default', builtin.exports);
       });
@@ -369,7 +773,7 @@ class BuiltinModule {
         const exportName = names[i];
         if (exportName === 'default') continue;
         this.module.setExport(exportName,
-                              getOwn(this.exports, exportName, this.exports));
+          getOwn(this.exports, exportName, this.exports));
       }
     }
   }
diff --git a/test/common/index.js b/test/common/index.js
index 6345a636a0..cc190e42a5 100644
--- a/test/common/index.js
+++ b/test/common/index.js
@@ -389,7 +389,7 @@ if (process.env.NODE_TEST_KNOWN_GLOBALS !== '0') {
     for (const val in global) {
       // globalThis.crypto is a getter that throws if Node.js was compiled
       // without OpenSSL.
-      if (val !== 'crypto' && !knownGlobals.includes(global[val])) {
+      if (val !== 'crypto' && val !== 'FORIN' && !knownGlobals.includes(global[val])) {
         leaked.push(val);
       }
     }
diff --git a/test/message/testcfg.py b/test/message/testcfg.py
index 4be454b55c..7ebb64ac0c 100644
--- a/test/message/testcfg.py
+++ b/test/message/testcfg.py
@@ -38,7 +38,12 @@ class MessageTestCase(test.TestCase):
 
   def __init__(self, path, file, expected, arch, mode, context, config):
     super(MessageTestCase, self).__init__(context, path, arch, mode)
-    self.file = file
+    # self.file = file
+    self.original_file = file
+    tmp = os.path.splitext(file)
+    base = tmp[0]
+    ext = tmp[1]
+    self.file = base + '-pp' + ext
     self.expected = expected
     self.config = config
     self.arch = arch
diff --git a/test/pseudo-tty/testcfg.py b/test/pseudo-tty/testcfg.py
index 4751188b44..9d59869236 100644
--- a/test/pseudo-tty/testcfg.py
+++ b/test/pseudo-tty/testcfg.py
@@ -42,7 +42,12 @@ class TTYTestCase(test.TestCase):
 
   def __init__(self, path, file, expected, input_arg, arch, mode, context, config):
     super(TTYTestCase, self).__init__(context, path, arch, mode)
-    self.file = file
+    # self.file = file
+    self.original_file = file
+    tmp = os.path.splitext(file)
+    base = tmp[0]
+    ext = tmp[1]
+    self.file = base + '-pp' + ext
     self.expected = expected
     self.input = input_arg
     self.config = config
diff --git a/test/testpy/__init__.py b/test/testpy/__init__.py
index c89ab6e8b5..a033d48360 100644
--- a/test/testpy/__init__.py
+++ b/test/testpy/__init__.py
@@ -39,7 +39,12 @@ class SimpleTestCase(test.TestCase):
 
   def __init__(self, path, file, arch, mode, context, config, additional=None):
     super(SimpleTestCase, self).__init__(context, path, arch, mode)
-    self.file = file
+    # self.file = file
+    self.original_file = file
+    tmp = os.path.splitext(file)
+    base = tmp[0]
+    ext = tmp[1]
+    self.file = base + '-pp' + ext
     self.config = config
     self.arch = arch
     self.mode = mode
diff --git a/tools/test.py b/tools/test.py
index d35b45a669..b534e8e42c 100755
--- a/tools/test.py
+++ b/tools/test.py
@@ -45,7 +45,11 @@ import multiprocessing
 import errno
 import copy
 import io
+import shutil
 
+def dump(obj):
+  for attr in dir(obj):
+    print("obj.%s = %r" % (attr, getattr(obj, attr)))
 
 if sys.version_info >= (3, 5):
   from importlib import machinery, util
@@ -95,6 +99,19 @@ os.environ.pop('NODE_OPTIONS', None)
 # --- P r o g r e s s   I n d i c a t o r s ---
 # ---------------------------------------------
 
+def LoadJSHelper(path):
+  skip = False
+  def predicate(line):
+    nonlocal skip
+    if (not skip) and ('%PLACEHOLDER% SKIP' in line):
+      skip = True
+      return False
+    if skip and ('%PLACEHOLDER% END' in line):
+      skip = False
+      return False
+    return not skip
+
+  return ''.join(filter(predicate, open(path, encoding='utf8').readlines()))
 
 class ProgressIndicator(object):
 
@@ -118,6 +135,11 @@ class ProgressIndicator(object):
     self.crashed = 0
     self.lock = threading.Lock()
     self.shutdown_event = threading.Event()
+    self.js_proxy = LoadJSHelper('../src/proxy.js')
+    self.js_buildins = LoadJSHelper('../src/buildins.js')
+    self.js_wrapper = LoadJSHelper('../src/wrapper.js')
+    self.taint_results_dir = generateNewResultPath('./fuzzing')
+    self.taint_init_data = loadTaintInitData()
 
   def GetFailureOutput(self, failure):
     output = []
@@ -192,6 +214,7 @@ class ProgressIndicator(object):
           return
       case = test
       case.thread_id = thread_id
+      case.taint_results_dir = self.taint_results_dir
       self.lock.acquire()
       case.serial_id = self.serial_id
       self.serial_id += 1
@@ -199,22 +222,56 @@ class ProgressIndicator(object):
       self.lock.release()
       try:
         start = datetime.now()
-        output = case.Run()
-        # SmartOS has a bug that causes unexpected ECONNREFUSED errors.
-        # See https://smartos.org/bugview/OS-2767
-        # If ECONNREFUSED on SmartOS, retry the test one time.
-        if (output.UnexpectedOutput() and
-          sys.platform == 'sunos5' and
-          'ECONNREFUSED' in output.output.stderr):
-            output = case.Run()
-            output.diagnostic.append('ECONNREFUSED received, test retried')
+        if not self.taint_init_data:
+          output = case.Run()
+          # SmartOS has a bug that causes unexpected ECONNREFUSED errors.
+          # See https://smartos.org/bugview/OS-2767
+          # If ECONNREFUSED on SmartOS, retry the test one time.
+          if (output.UnexpectedOutput() and
+            sys.platform == 'sunos5' and
+            'ECONNREFUSED' in output.output.stderr):
+              output = case.Run()
+              output.diagnostic.append('ECONNREFUSED received, test retried')
+        else:
+          if case.original_file in self.taint_init_data:
+            if ("test-debugger-" not in case.original_file and
+                "test-encoding" not in case.original_file):
+              exposes_internals = False
+              with open(case.original_file, "r") as file:
+                content = file.read()
+                exposes_internals = "--expose-internals" in content
+              if not exposes_internals:
+                unique_props = self.taint_init_data[case.original_file]['props']
+                print()
+                print(f'Running {(len(unique_props) + 1) * 2} mutated tests for {"/".join(case.path)}...')
+                for prop in unique_props:
+                  output = case.Run(prop) # self.js_buildins, self.js_wrapper,
+                  output = case.Run(prop, self.js_proxy)
+
+                output = case.Run("'FORIN'") # self.js_buildins, self.js_wrapper,
+                output = case.Run("'FORIN'", self.js_proxy)
+
+                moveToAnalyzed(self.taint_init_data[case.original_file]['files'])
+              else:
+                print()
+                print(f'Exclude a test that exposes internals: {"/".join(case.path)}.')
+                output = TestOutput(case, "", CommandOutput(0, False, "", ""), False)
+            else:
+              print()
+              print(f'Exclude a debugger test: {"/".join(case.path)}.')
+              output = TestOutput(case, "", CommandOutput(0, False, "", ""), False)
+          else:
+            print()
+            print(f'Skip mutated tests for {"/".join(case.path)}, not found props.')
+            output = TestOutput(case, "", CommandOutput(0, False, "", ""), False)
+
         case.duration = (datetime.now() - start)
       except IOError:
         return
       if self.shutdown_event.is_set():
         return
       self.lock.acquire()
-      if output.UnexpectedOutput():
+      if not self.taint_init_data and output.UnexpectedOutput():  # check output only for original (not mutated) test cases
         if FLAKY in output.test.outcomes and self.flaky_tests_mode == DONTCARE:
           self.flaky_failed.append(output)
         elif FLAKY in output.test.outcomes and self.flaky_tests_mode == KEEP_RETRYING:
@@ -561,6 +618,113 @@ class CommandOutput(object):
     self.stderr = stderr
     self.failed = None
 
+def uniquify(path):
+  if not os.path.exists(path):
+    return path
+
+  filename, extension = os.path.splitext(path)
+  counter = 1
+
+  while os.path.exists(path):
+      path = filename + "-" + str(counter) + extension
+      counter += 1
+
+  return path
+
+def generateNewResultPath(dir_path):
+  # Regular expression to match 'number-' pattern
+  pattern = re.compile(r'^(\d+)-')
+  n_max = 0
+  entries = os.listdir(dir_path)
+  for entry in entries:
+    match = pattern.match(entry)
+    if match and os.path.isdir(os.path.join(dir_path, entry)):
+      try:
+        # Extract number and update n_max if it's larger
+        n = int(match.group(1))
+        if n > n_max:
+          n_max = n
+      except ValueError:
+        # Skip if the entry after number is not valid
+        continue
+
+  # Generate new subdir name using n_max + 1 and current date
+  new_n = n_max + 1
+  current_date = datetime.now().strftime("%Y-%m-%d-%H-%M-%S")
+  new_subdir_name = f"{new_n}-{current_date}"
+
+  # Return the complete path of the new subdir
+  return os.path.join(dir_path, new_subdir_name)
+
+start_pattern = re.compile(r"===== START ===== \[(.*?)\]")
+undefined_prop_regex = re.compile(r'.+NOT FOUND:(.+<String\[\d+\]: #(?P<str_prop>.+)>| (?P<num_prop>\d+))')
+def collectUndefinedProps(taintLog):
+  test = ""
+  props = []
+  start = False
+  for line in taintLog:
+    line = line.strip()
+    if not start:
+      start_match = start_pattern.match(line)
+      if (start_match):
+        test = start_match.group(1).strip()
+        start = True
+      continue
+
+    # if line.startswith("[LoadIC::Load]") or line.startswith("[Runtime::GetObjectProperty]"):
+    prop_match = undefined_prop_regex.match(line)
+    if prop_match:
+      str_prop = prop_match.group('str_prop')
+      if str_prop:
+        props.append(f"'{str_prop.strip()}'")
+
+      num_prop = prop_match.group('num_prop')
+      if num_prop:
+        props.append(f"{num_prop.strip()}")
+
+  return test, list(set(props))
+
+
+def loadTaintInitData():
+  dir_path = './fuzzing/init'
+  taint_files = {}
+
+  if not os.path.exists(dir_path):
+    return taint_files
+
+  # Enumerate all files in the directory
+  for root, dirs, files in os.walk(dir_path):
+    for file in files:
+      file_path = os.path.join(root, file)
+      with open(file_path, 'r') as f:
+        test, props = collectUndefinedProps(f.readlines())
+        if test:
+          if test not in taint_files:
+            taint_files[test] = {'props': [], 'files': []}
+          taint_files[test]['props'] = list(set(taint_files[test]['props'] + props))
+          taint_files[test]['files'].append(file)
+
+  return taint_files
+
+def moveToAnalyzed(file_names):
+  source_dir = './fuzzing/init'
+  destination_dir = './fuzzing/init-analyzed'
+
+  # Ensure the destination directory exists
+  os.makedirs(destination_dir, exist_ok=True)
+
+  for file_name in file_names:
+    # Construct full file paths
+    source_path = os.path.join(source_dir, 'logs_1', file_name)
+    destination_path = os.path.join(destination_dir, file_name)
+
+    # Move the file
+    try:
+      shutil.move(source_path, destination_path)
+    except FileNotFoundError:
+      print(f"File {file_name} not found in {source_dir} for moving.")
+    except Exception as e:
+      print(f"An error occurred while moving the file: {e}")
 
 class TestCase(object):
 
@@ -601,15 +765,90 @@ class TestCase(object):
                       output,
                       self.context.store_unexpected_output)
 
-  def Run(self):
+  def Run(self, undefined_prop = '', js_proxy = '', js_buildins = '', js_wrapper = ''):
     try:
+      with open(self.file, 'w') as f:
+        f.write("// %TESTCASE%\n")
+        if undefined_prop:
+          if js_proxy:
+            f.write(js_proxy.replace('\n', ''))
+            ret_value = 'createProxy(returnValue)'
+          else:
+            ret_value = 'returnValue'
+
+          inj_code = '''let __pollutedValue = '0xEFFACED', __accessIndex = 0;
+Object.defineProperty(
+  Object.prototype,
+  %s,
+  {
+    get: function() {
+      const returnValue = __pollutedValue + __accessIndex;
+      __accessIndex += 1;
+
+      try {
+          throw new Error();
+      } catch(error) {
+          log(returnValue + ' source stack: ' + error.stack.replace(/\\n/g, '\\\\n'));
+      }
+
+      return %s;
+    },
+    set: function(newValue) {
+      Object.defineProperty(
+        this,
+        %s,
+        {
+          value: newValue,
+          writable: true,
+          enumerable: true,
+          configurable: true
+        }
+      );
+    },
+    enumerable: %s,
+    configurable: true
+  }
+);
+''' % (undefined_prop, ret_value, undefined_prop, ("true" if undefined_prop == "'FORIN'" else "false"))
+          f.write(inj_code.replace('\n', ''))
+          f.write("\n")
+          if js_wrapper:
+            f.write("{\n")
+            f.write(js_buildins)
+            f.write(js_wrapper)
+            f.write('''
+const { inspect } = require('util');
+function beforeFuncCallback(accessPath) {
+  log('[call]: ' + accessPath)
+//  if (accessPath === "REQUIRE('assert')") {
+//    return false;
+//  }
+
+  return false;
+}
+function afterFuncCallback(accessPath, args, ret) {
+  log('[ret]:  ' + accessPath)
+  //log('[ret]:  ' + accessPath + '-->' + inspect(ret, {breakLength: Infinity}))
+}
+
+const w = new Wrapper(log, beforeFuncCallback, afterFuncCallback);
+const m = require('module');
+m.prototype.require = w.wrap(m.prototype.require, 'REQUIRE');
+}
+''')
+        # LOG!!!
+        f.write(f'log("\\n===== START ===== [{self.original_file}] [{undefined_prop}]\\n");\n')
+        f.writelines(open(self.original_file, encoding='utf8').readlines())
+
       result = self.RunCommand(self.GetCommand(), {
         "TEST_SERIAL_ID": "%d" % self.serial_id,
         "TEST_THREAD_ID": "%d" % self.thread_id,
         "TEST_PARALLEL" : "%d" % self.parallel,
         "GITHUB_STEP_SUMMARY": "",
       })
+
     finally:
+      os.remove(self.file)
       # Tests can leave the tty in non-blocking mode. If the test runner
       # tries to print to stdout/stderr after that and the tty buffer is
       # full, it'll die with a EAGAIN OSError. Ergo, put the tty back in
@@ -661,7 +900,6 @@ class TestOutput(object):
     else:
       return execution_failed
 
-
 def KillProcessWithID(pid, signal_to_send=signal.SIGTERM):
   if utils.IsWindows():
     os.popen('taskkill /T /F /PID %d' % pid)
@@ -687,12 +925,12 @@ def Win32SetErrorMode(mode):
 
 
 def KillTimedOutProcess(context, pid):
-  signal_to_send = signal.SIGTERM
+  signal_to_send = signal.SIGTERM #SIGKILL
   if context.abort_on_timeout:
     # Using SIGABRT here allows the OS to generate a core dump that can be
     # looked at post-mortem, which helps for investigating failures that are
     # difficult to reproduce.
-    signal_to_send = signal.SIGABRT
+    signal_to_send = signal.SIGTERM #SIGKILL
   KillProcessWithID(pid, signal_to_send)
 
 
@@ -942,7 +1180,9 @@ class Context(object):
   def GetVm(self, arch, mode):
     if self.vm is not None:
       return self.vm
-    if arch == 'none':
+    if arch == 'sys':
+      name = '/home/yuske/.nvm/versions/node/v21.0.0/bin/node'
+    elif arch == 'none':
       name = 'out/Debug/node' if mode == 'debug' else 'out/Release/node'
     else:
       name = 'out/%s.%s/node' % (arch, mode)
@@ -1590,8 +1830,13 @@ def get_env_type(vm, options_type, context):
 def get_asan_state():
   return "on" if os.environ.get('ASAN') is not None else "off"
 
+def ignore_signal(signum, frame):
+  print("Received SIGTERM, but ignoring it.")
 
 def Main():
+  # Registering the signal handler
+  signal.signal(signal.SIGTERM, ignore_signal)
+
   parser = BuildOptions()
   (options, args) = parser.parse_args()
   if not ProcessOptions(options):
@@ -1797,7 +2042,7 @@ def Main():
     for failure in result['failed']:
       print(EscapeCommand(failure.command))
 
-  return exitcode
+  return 0 #exitcode
 
 
 if __name__ == '__main__':
